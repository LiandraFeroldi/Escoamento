import numpy as np
import pandas as pd
from math import exp, pi, sin, radians

# --- 1. DADOS DO PROBLEMA E CONSTANTES ---

BSW = 0.25                 # fração volumétrica de água na fase líquida
API = 30
DG = 0.7                   # gravidade específica do gás (adimensional)
DO_STD = 141.5 / (API + 131.5)  # SG do óleo (adimensional)

# Densidades (apenas estimativas para teste)
RHO_O_STD = DO_STD * 1000      # kg/m3
RHO_W_STD = 1000               # kg/m3
RHO_GAS_SIM = DG * 1.225       # kg/m3 (aprox. dg * rho_ar)
Q_ST_M3_S = 5000 / 86400       # m3/s (exemplo)

# Vazão mássica total (assumida a partir de vazões padrão)
Q_OLEO_ST = Q_ST_M3_S * (1 - BSW)
Q_AGUA_ST = Q_ST_M3_S * BSW
M_DOT = (Q_OLEO_ST * RHO_O_STD) + (Q_AGUA_ST * RHO_W_STD)  # kg/s (exemplo)

# Calores específicos constantes (estimativas)
CP_WATER_CONST = 4180  # J/kgK
CP_GAS_CONST = 2100    # J/kgK

# Geometria / termofísicos
G_ACCEL = 9.81
Z_RES = 2100; T_RES_C = 80
Z_BOMBA = 950; T_LEITO_C = 4
Z_MANIFOLD = 850; T_SURFACE_C = 17

D_PIPE = 0.1
TEC_POCO = 2; TEC_MARINHO = 1
ANGLE_LEITO_DEG = 37
DL = 10

# Holdup fixo só para testes — substituir por Beggs&Brill em integração final
HL_SIMPLIFICADO = 0.6


# ================================================================
# 2) FUNÇÕES DE PROPRIEDADES TÉRMICAS
# ================================================================
def cp_oil(Tf_C, SG_oil):
    # mesma correlação que você tinha
    termo1 = (2e-3 * Tf_C - 1.429) * SG_oil
    termo2 = (2.67e-3) * Tf_C
    termo3 = 3.049
    Cp_o_kJ = termo1 + termo2 + termo3
    return Cp_o_kJ * 1000  # J/kg.K

def cp_liquid(BSW, cp_water, cp_oil):
    return BSW * cp_water + (1 - BSW) * cp_oil

def cp_mixture(HL, rho_liq, rho_gas, cp_liq, cp_gas):
    m_liq = HL * rho_liq
    m_gas = (1 - HL) * rho_gas
    m_total = m_liq + m_gas + 1e-12
    w_liq = m_liq / m_total
    w_gas = m_gas / m_total
    return w_liq * cp_liq + w_gas * cp_gas


# ================================================================
# 3) FUNÇÃO CORRETA DE ATUALIZAÇÃO TÉRMICA (USANDO DL)
# ================================================================
def update_temperature(T_ext_local, T_old, DL, m_dot, Cp_mix, TEC, diameter):
    """
    Solução analítica do balanço: dTf/dx = - (U*A)/(m_dot*Cp) (Tf - T_ext)
    Tf_new = T_ext + (Tf_old - T_ext) * exp(- (U*A)/ (m_dot*Cp) * DL)
    """
    r = diameter / 2.0
    A_surf_per_m = 2.0 * pi * r      # m2 por metro de comprimento
    UA_per_m = TEC * A_surf_per_m    # W/(m·K)
    expo = - (UA_per_m * DL) / max(m_dot * Cp_mix, 1e-12)
    Tf_new = T_ext_local + (T_old - T_ext_local) * exp(expo)
    return Tf_new


# ================================================================
# 4) FUNÇÕES AUXILIARES
# ================================================================
def get_external_temp_C(Z_cum_start, Z_cum_end, Z_current_cota, T_ext_start, T_ext_end):
    if Z_cum_start == Z_cum_end:
        return T_ext_start
    Z_total_section = Z_cum_start - Z_cum_end
    T_grad = (T_ext_end - T_ext_start) / Z_total_section
    Z_relativo = Z_cum_start - Z_current_cota
    return T_ext_start + T_grad * Z_relativo

def calculate_pipe_length(depth_diff, angle_deg):
    if angle_deg == 90 or depth_diff == 0:
        return depth_diff
    angle_rad = radians(angle_deg)
    return depth_diff / sin(angle_rad)


# ================================================================
# 5) LOOP PRINCIPAL (COM CORREÇÕES)
# ================================================================
L_INCLINADO = calculate_pipe_length(Z_BOMBA - Z_MANIFOLD, ANGLE_LEITO_DEG)

TRECHOS = [
    {'Nome':'Poço (Vertical)', 'Z_START':Z_RES, 'Z_END':Z_BOMBA, 'L_SECTION':Z_RES - Z_BOMBA, 'ANGLE_DEG':90, 'TEC':TEC_POCO, 'T_EXT_START':T_RES_C, 'T_EXT_END':T_LEITO_C},
    {'Nome':'Leito Marinho (Inclinado)', 'Z_START':Z_BOMBA, 'Z_END':Z_MANIFOLD, 'L_SECTION':L_INCLINADO, 'ANGLE_DEG':ANGLE_LEITO_DEG, 'TEC':TEC_MARINHO, 'T_EXT_START':T_LEITO_C, 'T_EXT_END':T_LEITO_C},
    {'Nome':'Riser (Vertical)', 'Z_START':Z_MANIFOLD, 'Z_END':0, 'L_SECTION':Z_MANIFOLD, 'ANGLE_DEG':90, 'TEC':TEC_MARINHO, 'T_EXT_START':T_LEITO_C, 'T_EXT_END':T_SURFACE_C}
]

results = []
L_cum = 0.0
current_Tf_C = T_RES_C
current_Z_cota = Z_RES

for trecho in TRECHOS:
    L_section = trecho['L_SECTION']
    TEC = trecho['TEC']
    T_ext_start_C = trecho['T_EXT_START']
    T_ext_end_C = trecho['T_EXT_END']
    theta_rad = radians(trecho['ANGLE_DEG'])

    # se não for o primeiro trecho, atualiza a entrada com a saída anterior
    if L_cum > 0 and len(results) > 0:
        current_Tf_C = results[-1]['T_fluido_C']
        current_Z_cota = results[-1]['Z_m']

    num_steps = int(L_section / DL)
    for i in range(num_steps):
        dz = DL * sin(theta_rad)
        Z_new_cota = current_Z_cota - dz
        L_cum += DL

        T_ext_C = get_external_temp_C(trecho['Z_START'], trecho['Z_END'], Z_new_cota, T_ext_start_C, T_ext_end_C)

        # propriedades locais (usando HL simplificado aqui)
        Cp_o = cp_oil(current_Tf_C, DO_STD)
        Cp_liq = cp_liquid(BSW, CP_WATER_CONST, Cp_o)
        rho_liq = RHO_W_STD * BSW + RHO_O_STD * (1 - BSW)
        Cp_mix = cp_mixture(HL_SIMPLIFICADO, rho_liq, RHO_GAS_SIM, Cp_liq, CP_GAS_CONST)

        # corrigido: usar DL (passo) e m_dot local (aqui M_DOT simples)
        Tf_new_C = update_temperature(T_ext_C, current_Tf_C, DL, M_DOT, Cp_mix, TEC, D_PIPE)

        results.append({
            'L_cum_m': L_cum,
            'Z_m': Z_new_cota,
            'Trecho': trecho['Nome'],
            'T_fluido_C': Tf_new_C,
            'T_ext_C': T_ext_C,
            'Cp_mix_JkgK': Cp_mix,
            'HL_assumido': HL_SIMPLIFICADO
        })

        current_Tf_C = Tf_new_C
        current_Z_cota = Z_new_cota

# salvar
df_results = pd.DataFrame(results)
df_results.to_excel("perfil_temperatura_corrigido.xlsx", index=False)
print("Simulação concluída. Arquivo: perfil_temperatura_corrigido.xlsx")
print(f"Temperatura final na superfície: {df_results['T_fluido_C'].iloc[-1]:.2f} °C")
